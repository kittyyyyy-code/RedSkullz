/* CatCafe Chat — Single-file React prototype (App.jsx) Features included: - Create/join private group rooms with invite code - Text chat with images (drag & drop / file upload) and stickers - Profile customization (avatar, sticker, accent color) - Voice & video group call using WebRTC (requires a simple signalling server; server code included below) - Reactions, message editing/deleting (local), pins, and simple search - Cat-themed UI: paw icons, cat stickers, playful fonts and colors How to run (frontend): 1. Create a new React app (Vite or Create React App). Replace src/App.jsx with this file and add Tailwind. 2. Start local signalling server (optional for real multi-peer calls): node signalling-server.js 3. Run frontend: npm run dev Signalling server (optional) is included below in the same file; copy to signalling-server.js This single-file prototype intentionally keeps everything client-side (except signalling) so you can test and expand. */ import React, { useEffect, useRef, useState } from "react"; // Minimal CSS-in-JS for playful cat theme (Tailwind recommended, but we include lightweight styles) const styles = { app: `min-h-screen bg-gradient-to-br from-indigo-50 via-pink-50 to-yellow-50 font-sans`, container: `max-w-6xl mx-auto p-4`, header: `flex items-center justify-between py-4`, logo: `flex items-center gap-3 text-2xl font-bold`, card: `bg-white/80 backdrop-blur rounded-2xl shadow-lg p-4`, sidebar: `w-72`, main: `flex-1 ml-4` }; // Utilities const uid = (n = 6) => Math.random().toString(36).slice(2, 2 + n); // Default stickers (cat-themed) — you can replace with image URLs const STICKERS = ["😺", "🐾", "😻", "😽", "🪄", "🌸", "🍣", "☕️"]; // Simple local persistence helpers const save = (k, v) => localStorage.setItem(k, JSON.stringify(v)); const load = (k, fallback) => { try { return JSON.parse(localStorage.getItem(k)) ?? fallback; } catch (e) { return fallback; } }; // ---------- WebRTC signalling helper (uses WebSocket server) // For multi-peer mesh calls each client must connect to a signalling server which relays SDP offers and ICE candidates. // A minimal Node signalling server implementation is included at the bottom of this file (signalling-server.js). function useSignalling(serverUrl, roomId, onMessage) { const wsRef = useRef(null); useEffect(() => { if (!serverUrl || !roomId) return; const ws = new WebSocket(serverUrl); wsRef.current = ws; ws.onopen = () => { ws.send(JSON.stringify({ type: "join", room: roomId })); }; ws.onmessage = (ev) => { const data = JSON.parse(ev.data); if (onMessage) onMessage(data); }; ws.onclose = () => console.log("signalling closed"); return () => { ws.close(); }; }, [serverUrl, roomId]); const send = (payload) => { if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) { wsRef.current.send(JSON.stringify(payload)); } }; return { send }; } // ---------- Main App export default function App() { // user profile const [profile, setProfile] = useState(() => load("catcafe:profile", { id: uid(8), name: "Whiskers", color: "#f59e0b", sticker: STICKERS[2] })); // rooms stored locally const [rooms, setRooms] = useState(() => load("catcafe:rooms", {})); const [currentRoom, setCurrentRoom] = useState(null); // messages per room const [messages, setMessages] = useState(() => load("catcafe:messages", {})); // UI state const [text, setText] = useState(""); const [search, setSearch] = useState(""); // calling state const [inCall, setInCall] = useState(false); const localVideoRef = useRef(null); const remoteVideosRef = useRef({}); const localStreamRef = useRef(null); const peersRef = useRef({}); // signalling config (change if you run signalling server) const SIGNALING_URL = "ws://localhost:8888"; // update if needed // handle messages send/receive (local only for prototype) const sendMessage = (roomId, msg) => { const roomMsgs = messages[roomId] ?? []; const newMsg = { id: uid(8), user: profile, text: msg.text ?? null, time: Date.now(), type: msg.type ?? 'text', meta: msg.meta ?? {} }; const updated = { ...messages, [roomId]: [...roomMsgs, newMsg] }; setMessages(updated); save("catcafe:messages", updated); }; useEffect(() => save("catcafe:rooms", rooms), [rooms]); useEffect(() => save("catcafe:profile", profile), [profile]); // Join or create room const createRoom = ({ name }) => { const id = uid(5).toUpperCase(); const r = { id, name, created: Date.now(), members: [profile.id], pinned: null }; const updated = { ...rooms, [id]: r }; setRooms(updated); setCurrentRoom(id); }; const joinRoom = (id) => { if (!rooms[id]) { // create a placeholder room when joining by code const r = { id, name: `Room ${id}`, created: Date.now(), members: [profile.id], pinned: null }; setRooms(prev => { const u = { ...prev, [id]: r }; save("catcafe:rooms", u); return u; }); } setCurrentRoom(id); }; // file upload for image messages const handleFile = (file) => { if (!currentRoom) return; const reader = new FileReader(); reader.onload = () => { sendMessage(currentRoom, { type: 'image', text: null, meta: { src: reader.result, name: file.name } }); }; reader.readAsDataURL(file); }; // simple message send const submit = (e) => { e?.preventDefault(); if (!text.trim() || !currentRoom) return; sendMessage(currentRoom, { text: text.trim() }); setText(""); }; // ----- Simple WebRTC call flow (mesh) ----- const signalling = useSignalling(SIGNALING_URL, currentRoom, async (data) => { // handle incoming signalling messages const { from, to, action, payload } = data; if (to && to !== profile.id) return; // ignore if (action === 'new-peer' && payload?.id && payload.id !== profile.id) { // create peer connection and initiate await createPeer(payload.id, true); } if (action === 'offer' && payload?.sdp) { await createPeer(from, false, payload.sdp); } if (action === 'answer' && payload?.sdp) { const pc = peersRef.current[from]?.pc; if (pc) pc.setRemoteDescription(new RTCSessionDescription(payload.sdp)); } if (action === 'ice' && payload?.candidate) { const pc = peersRef.current[from]?.pc; if (pc) pc.addIceCandidate(new RTCIceCandidate(payload.candidate)).catch(console.error); } }); async function createPeer(peerId, initiator = false, remoteSdp = null) { if (peersRef.current[peerId]) return; // already connected const pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] }); peersRef.current[peerId] = { pc }; // add local tracks if (localStreamRef.current) { localStreamRef.current.getTracks().forEach(t => pc.addTrack(t, localStreamRef.current)); } pc.ontrack = (ev) => { // show remote stream in a video element const stream = ev.streams[0]; remoteVideosRef.current[peerId] = stream; // trigger re-render setInCall(s => s); }; pc.onicecandidate = (e) => { if (e.candidate) { signalling.send({ type: 'signal', action: 'ice', to: peerId, from: profile.id, payload: { candidate: e.candidate } }); } }; if (initiator) { const offer = await pc.createOffer(); await pc.setLocalDescription(offer); signalling.send({ type: 'signal', action: 'offer', to: peerId, from: profile.id, payload: { sdp: pc.localDescription } }); } else if (remoteSdp) { await pc.setRemoteDescription(new RTCSessionDescription(remoteSdp)); const answer = await pc.createAnswer(); await pc.setLocalDescription(answer); signalling.send({ type: 'signal', action: 'answer', to: peerId, from: profile.id, payload: { sdp: pc.localDescription } }); } } const startCall = async () => { if (!currentRoom) return alert('Join a room first!'); // get media try { const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: true }); localStreamRef.current = stream; if (localVideoRef.current) localVideoRef.current.srcObject = stream; setInCall(true); // notify signalling server there is a new peer signalling.send({ type: 'signal', action: 'ready', from: profile.id, payload: { id: profile.id } }); } catch (e) { console.error(e); alert('Microphone / camera access denied'); } }; const leaveCall = () => { setInCall(false); if (localVideoRef.current) localVideoRef.current.srcObject = null; if (localStreamRef.current) { localStreamRef.current.getTracks().forEach(t => t.stop()); localStreamRef.current = null; } // close peer connections Object.values(peersRef.current).forEach(p => { try { p.pc.close(); } catch {} }); peersRef.current = {}; remoteVideosRef.current = {}; }; // helper to render messages (search filter applied) const roomMessages = currentRoom ? (messages[currentRoom] ?? []) : []; const filtered = search.trim() ? roomMessages.filter(m => (m.text || m.meta?.name || '').toLowerCase().includes(search.toLowerCase())) : roomMessages; return (
🐾
CatCafe Chat
Cozy meetings & hangouts for your comic team
{profile.sticker}
{profile.name}
Rooms

{Object.values(rooms).map(r => (
joinRoom(r.id)}>
{r.name}
{r.id}
))}
{e.preventDefault(); createRoom({ name: e.target.roomName.value || 'Cozy Corner' }); e.target.roomName.value=''; }}>    Create
Join by code

  { const v=document.getElementById('joincode').value.trim().toUpperCase(); if (v) joinRoom(v); }}>Join
Profile

setProfile(p=>({...p, name:e.target.value}))} className="w-full p-2 rounded-md border mt-2" />
{STICKERS.map(s => (  setProfile(p=>({...p, sticker:s}))} className={`p-2 rounded-md ${profile.sticker===s? 'ring-2':''}`}>{s} ))}
Accent color  setProfile(p=>({...p, color:e.target.value}))} className="w-full" />
{currentRoom ? rooms[currentRoom]?.name ?? `Room ${currentRoom}` : 'No room joined'}
{currentRoom ? `Code: ${currentRoom}` : 'Create or join a room to start'}
setSearch(e.target.value)} className="p-2 rounded-md border" />  📞 Join Call  🚪 Leave Call
{/* Chat area */}
{filtered.map(m => (
{m.user.sticker}
{m.user.name} {new Date(m.time).toLocaleTimeString()}
{m.type==='text' &&
{m.text}
} {m.type==='image' &&
{m.meta.name}
}
))}
setText(e.target.value)} placeholder="Type a message..." className="flex-1 p-3 rounded
-xl border" /> 📎 { if (e.target.files?.[0]) handleFile(e.target.files[0]); }} />
{STICKERS.map(s=> sendMessage(currentRoom, { type: 'text', text: s })} className="p-2">{s})}
Send
{/* Call area */}
Call Stage

Local

Remote
{Object.entries(remoteVideosRef.current).map(([id, stream]) => ( ))} {Object.keys(remoteVideosRef.current).length===0 &&
No remote participants yet. When others join the call they'll appear here.
}
); } function RemoteVideo({ stream, id }) { const ref = useRef(null); useEffect(()=>{ if (ref.current && stream) ref.current.srcObject = stream; },[stream]); return (

); } /* ----------------- Signalling server (Node.js) ----------------- Copy the following code into signalling-server.js and run: node signalling-server.js This is a tiny WebSocket server that routes signalling messages inside rooms. It is intentionally minimal—use a production-ready signaling server for a real app. // signalling-server.js const WebSocket = require('ws'); const wss = new WebSocket.Server({ port: 8888 }); const rooms = {}; // roomId -> set of sockets wss.on('connection', function connection(ws) { ws.on('message', function incoming(message) { try { const data = JSON.parse(message); if (data.type === 'join') { const room = data.room; ws.room = room; rooms[room] = rooms[room] || new Set(); rooms[room].add(ws); // notify others a new peer joined rooms[room].forEach(s => { if (s !== ws) s.send(JSON.stringify({ type: 'signal', action: 'new-peer', from: 'server', payload: { id: data.id || 'peer' } })); }); } if (data.type === 'signal') { // broadcast to room const room = ws.room; if (!room) return; rooms[room].forEach(s => { if (s !== ws) s.send(message); }); } } catch(e) { console.error('invalid message', e); } }); ws.on('close', ()=>{ if (ws.room && rooms[ws.room]) { rooms[ws.room].delete(ws); } }); }); ------------------------------------------------------------------ */
