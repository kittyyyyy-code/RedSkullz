import React, { useEffect, useState, useRef } from "react";

// Hexagon RP Chat - Single-file React app
// Tailwind CSS assumed available in the environment (Replit / Stackblitz / Vite with Tailwind)
// Features implemented (v1):
// - Character creation & switch (saved in localStorage)
// - Multiple rooms with persistent messages (localStorage)
// - Theme selector (several cat-themed themes)
// - Send messages, /me action, /roll dice, /whisper
// - Edit/Delete own messages
// - Image attachments (stored as base64 in localStorage)
// - Emote picker and sticker support
// - Export room logs as HTML
// - Basic decorative animations, paw cursor, cursor trails
// - Simple sound toggles and ambience per room

// ----------------------------- Helpers ---------------------------------
const uid = (n = 8) => Math.random().toString(36).slice(2, 2 + n);

const defaultRooms = [
  { id: "rustys", name: "Rusty's Diner", bg: "rusty", ambience: "diner" },
  { id: "dreamfield", name: "Dream Field", bg: "dream", ambience: "dream" },
  { id: "skyhouse", name: "Sky House", bg: "sky", ambience: "sky" },
];

const THEMES = {
  pastel: {
    name: "Cat Café Pastel",
    bg: "bg-gradient-to-br from-pink-50 via-yellow-50 to-blue-50",
    bubble: "bg-white/80",
  },
  cyber: {
    name: "Cyber Neko Glow",
    bg: "bg-gradient-to-br from-indigo-900 via-purple-700 to-pink-600",
    bubble: "bg-black/50",
  },
  msn: {
    name: "2000s Sparkle MSN",
    bg: "bg-gradient-to-r from-sky-100 to-rose-100",
    bubble: "bg-white/90",
  },
  rusty: {
    name: "Rusty's Retro Diner",
    bg: "bg-gradient-to-br from-amber-50 via-amber-100 to-orange-50",
    bubble: "bg-white/95",
  },
};

// localStorage keys
const LS = {
  CHARS: "hex_chars",
  ROOMS: "hex_rooms",
  CUR_CHAR: "hex_current_char",
  THEME: "hex_theme",
};

// ----------------------------- App -------------------------------------
export default function App() {
  // Load rooms
  const [rooms, setRooms] = useState(() => {
    try {
      const v = JSON.parse(localStorage.getItem(LS.ROOMS));
      return v && v.length ? v : defaultRooms;
    } catch (e) {
      return defaultRooms;
    }
  });

  const [currentRoom, setCurrentRoom] = useState(rooms[0].id);
  const [themeKey, setThemeKey] = useState(() => localStorage.getItem(LS.THEME) || "pastel");

  // Characters
  const [chars, setChars] = useState(() => {
    try {
      return JSON.parse(localStorage.getItem(LS.CHARS)) || [];
    } catch (e) {
      return [];
    }
  });
  const [currentCharId, setCurrentCharId] = useState(() => localStorage.getItem(LS.CUR_CHAR) || (chars[0] && chars[0].id) || null);

  // Messages stored in localStorage per room under key messages_{roomId}
  const [messages, setMessages] = useState(() => loadMessages(rooms[0].id));

  const [input, setInput] = useState("");
  const [showCreateChar, setShowCreateChar] = useState(false);
  const [showProfileEditor, setShowProfileEditor] = useState(false);
  const [soundOn, setSoundOn] = useState(true);
  const [emoteOpen, setEmoteOpen] = useState(false);
  const [imagePreview, setImagePreview] = useState(null);

  const msgRef = useRef(null);

  // Sync when room changes
  useEffect(() => {
    setMessages(loadMessages(currentRoom));
  }, [currentRoom]);

  useEffect(() => localStorage.setItem(LS.ROOMS, JSON.stringify(rooms)), [rooms]);
  useEffect(() => localStorage.setItem(LS.CHARS, JSON.stringify(chars)), [chars]);
  useEffect(() => localStorage.setItem(LS.CUR_CHAR, currentCharId || ""), [currentCharId]);
  useEffect(() => localStorage.setItem(LS.THEME, themeKey), [themeKey]);

  useEffect(() => {
    // Scroll to bottom on messages change
    if (msgRef.current) {
      msgRef.current.scrollTop = msgRef.current.scrollHeight;
    }
  }, [messages]);

  // ---------------- Message helpers ----------------
  function messagesKey(roomId) {
    return `hex_messages_${roomId}`;
  }
  function loadMessages(roomId) {
    try {
      return JSON.parse(localStorage.getItem(messagesKey(roomId))) || [];
    } catch (e) {
      return [];
    }
  }
  function saveMessages(roomId, msgs) {
    localStorage.setItem(messagesKey(roomId), JSON.stringify(msgs));
  }

  function addMessage(data) {
    const msgs = loadMessages(currentRoom);
    msgs.push(data);
    saveMessages(currentRoom, msgs);
    setMessages([...msgs]);
    if (soundOn) playSFX("send");
  }

  function handleSend(e) {
    e && e.preventDefault();
    if (!currentCharId) return alert("Pick or create a character first!");
    const character = chars.find((c) => c.id === currentCharId);
    if (!character) return alert("Your character could not be found.");

    const text = input.trim();
    if (!text && !imagePreview) return;

    // Command parsing
    if (text.startsWith("/")) {
      const tokens = text.split(" ");
      const cmd = tokens[0].slice(1);
      if (cmd === "me") {
        const action = tokens.slice(1).join(" ");
        addMessage(makeMessage(character, `*${action}*`, "action"));
      } else if (cmd === "roll") {
        const expr = tokens[1] || "1d20";
        const res = rollDice(expr);
        addMessage(makeMessage(character, `🎲 rolled ${expr} → **${res.result}**`));
      } else if (cmd === "whisper") {
        const target = tokens[1];
        const rest = tokens.slice(2).join(" ");
        addMessage(makeMessage(character, `(whisper to ${target}) ${rest}`, "whisper"));
      } else {
        addMessage(makeMessage(character, text));
      }
    } else {
      addMessage(makeMessage(character, text, "say", imagePreview));
    }

    setInput("");
    setImagePreview(null);
  }

  function makeMessage(character, text, type = "say", image = null) {
    return {
      id: uid(10),
      charId: character.id,
      name: character.name,
      avatar: character.avatar,
      color: character.color,
      text,
      type,
      image,
      time: new Date().toISOString(),
    };
  }

  function rollDice(expr) {
    // supports NdM simple like 2d6 or 1d20
    const m = expr.match(/(\d+)d(\d+)/i);
    if (!m) {
      // fallback single number
      const n = parseInt(expr, 10) || 0;
      return { result: n };
    }
    const times = parseInt(m[1], 10);
    const sides = parseInt(m[2], 10);
    let total = 0;
    for (let i = 0; i < times; i++) total += 1 + Math.floor(Math.random() * sides);
    return { result: total };
  }

  function playSFX(name) {
    // minimal SFX via oscillator (no external files)
    try {
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.type = "sine";
      o.frequency.value = name === "send" ? 880 : 660;
      g.gain.value = 0.02;
      o.connect(g);
      g.connect(ctx.destination);
      o.start();
      setTimeout(() => {
        o.stop();
        ctx.close();
      }, 80);
    } catch (e) {}
  }

  function handleImageUpload(file) {
    const reader = new FileReader();
    reader.onload = function (ev) {
      setImagePreview(ev.target.result);
    };
    reader.readAsDataURL(file);
  }

  // Message edit & delete
  function editMessage(msgId, newText) {
    const msgs = loadMessages(currentRoom).map((m) => (m.id === msgId ? { ...m, text: newText, edited: true } : m));
    saveMessages(currentRoom, msgs);
    setMessages([...msgs]);
  }
  function deleteMessage(msgId) {
    const msgs = loadMessages(currentRoom).filter((m) => m.id !== msgId);
    saveMessages(currentRoom, msgs);
    setMessages([...msgs]);
  }

  // Export logs
  function exportRoom(roomId) {
    const msgs = loadMessages(roomId);
    const html = `<!doctype html><html><head><meta charset=\"utf-8\"><title>Hexagon - ${roomId} Log</title></head><body><h1>Room: ${roomId}</h1>${msgs
      .map((m) => `<p><b>${m.name}</b> [${new Date(m.time).toLocaleString()}]: ${escapeHtml(m.text)}${m.image ? `<div><img src='${m.image}' style='max-width:200px'/></div>` : ""}</p>`)
      .join("")}</body></html>`;
    const blob = new Blob([html], { type: "text/html" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `hexagon_${roomId}_log.html`;
    a.click();
    URL.revokeObjectURL(url);
  }

  // Utility
  function escapeHtml(s) {
    return s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  }

  // Create character
  function createCharacter({ name, pronouns, species, color, avatar, bio }) {
    const c = {
      id: uid(10),
      name: name || "Unnamed Cat",
      pronouns: pronouns || "they/them",
      species: species || "human",
      color: color || "#7f9cf5",
      avatar: avatar || null,
      bio: bio || "",
      createdAt: new Date().toISOString(),
    };
    const newChars = [...chars, c];
    setChars(newChars);
    setCurrentCharId(c.id);
    return c;
  }

  function updateCharacter(updated) {
    const newChars = chars.map((c) => (c.id === updated.id ? updated : c));
    setChars(newChars);
  }

  function addRoom(name, bg = "rusty") {
    const r = { id: uid(8), name, bg, ambience: "custom" };
    const newRooms = [...rooms, r];
    setRooms(newRooms);
    setCurrentRoom(r.id);
  }

  // ---------------- UI pieces -----------------

  return (
    <div className={`min-h-screen flex flex-col ${THEMES[themeKey].bg} text-gray-900`}>
      <Header
        themeKey={themeKey}
        setThemeKey={setThemeKey}
        themes={THEMES}
        soundOn={soundOn}
        setSoundOn={setSoundOn}
      />
      <div className="flex flex-1 overflow-hidden">
        <Sidebar
          rooms={rooms}
          currentRoom={currentRoom}
          setCurrentRoom={setCurrentRoom}
          addRoom={addRoom}
          chars={chars}
          currentCharId={currentCharId}
          setCurrentCharId={setCurrentCharId}
          setShowCreateChar={setShowCreateChar}
          setShowProfileEditor={setShowProfileEditor}
          exportRoom={exportRoom}
        />

        <main className="flex-1 p-4 flex flex-col" style={{ position: "relative" }}>
          <RoomHeader room={rooms.find((r) => r.id === currentRoom)} />

          <div
            ref={msgRef}
            className="flex-1 overflow-auto rounded-lg p-4 scrollbar-thumb-rounded scrollbar-thin scrollbar-thumb-gray-300"
            style={{ background: "rgba(255,255,255,0.3)" }}
          >
            <MessageList
              messages={messages}
              chars={chars}
              currentCharId={currentCharId}
              onEdit={editMessage}
              onDelete={deleteMessage}
            />
          </div>

          <div className="mt-3 bg-white/80 p-3 rounded-lg shadow-md">
            <form onSubmit={handleSend} className="flex gap-2 items-end">
              <div className="flex-1">
                <textarea
                  value={input}
                  onChange={(e) => setInput(e.target.value)}
                  rows={2}
                  placeholder={'Type a message... (commands: /me /roll 1d20 /whisper @name)'}
                  className="w-full p-2 rounded-md resize-none"
                />
                {imagePreview && (
                  <div className="mt-2 flex items-center gap-2">
                    <img src={imagePreview} alt="preview" className="w-24 h-24 object-cover rounded-md border" />
                    <button
                      type="button"
                      className="text-sm underline"
                      onClick={() => setImagePreview(null)}
                    >
                      Remove Image
                    </button>
                  </div>
                )}
              </div>

              <div className="flex flex-col items-center gap-2">
                <label className="cursor-pointer bg-amber-200 p-2 rounded-md hover:scale-105 transition-transform">
                  📷
                  <input
                    type="file"
                    accept="image/*"
                    className="hidden"
                    onChange={(e) => handleImageUpload(e.target.files[0])}
                  />
                </label>

                <button
                  type="button"
                  className="bg-indigo-500 text-white px-4 py-2 rounded-md"
                  onClick={() => setEmoteOpen((s) => !s)}
                >
                  😺
                </button>

                <button type="submit" className="bg-emerald-500 text-white px-4 py-2 rounded-md">
                  Send
                </button>
              </div>
            </form>

            {emoteOpen && (
              <div className="mt-2 grid grid-cols-6 gap-2">
                {EMOTES.map((e) => (
                  <button
                    key={e}
                    className="p-2 bg-white rounded-md shadow-sm"
                    onClick={() => {
                      setInput((s) => s + " " + e + " ");
                      setEmoteOpen(false);
                    }}
                  >
                    {e}
                  </button>
                ))}
              </div>
            )}
          </div>

          <footer className="mt-3 flex justify-between items-center text-sm text-gray-700">
            <div>Theme: <b>{THEMES[themeKey].name}</b></div>
            <div className="flex items-center gap-3">
              <button
                onClick={() => setShowCreateChar(true)}
                className="bg-pink-300 px-3 py-1 rounded-md"
              >
                Create Character
              </button>
              <button
                onClick={() => setShowProfileEditor(true)}
                className="bg-sky-300 px-3 py-1 rounded-md"
              >
                Edit Profile
              </button>
            </div>
          </footer>
        </main>
      </div>

      {/* Floating decorations */}
      <FloatingPaws />

      {/* Modals */}
      {showCreateChar && (
        <CreateCharModal
          onClose={() => setShowCreateChar(false)}
          onCreate={(data) => {
            createCharacter(data);
            setShowCreateChar(false);
          }}
        />
      )}
      {showProfileEditor && (
        <ProfileEditor
          char={chars.find((c) => c.id === currentCharId)}
          onClose={() => setShowProfileEditor(false)}
          onSave={(c) => {
            updateCharacter(c);
            setShowProfileEditor(false);
          }}
        />
      )}
    </div>
  );
}

// ----------------- Subcomponents -----------------

function Header({ themeKey, setThemeKey, themes, soundOn, setSoundOn }) {
  return (
    <header className="py-3 px-4 flex items-center justify-between border-b">
      <div className="flex items-center gap-3">
        <div className="text-2xl font-bold">🐾 Hexagon RP Chat</div>
        <div className="text-sm text-gray-600">(No sign-up • Local saves)</div>
      </div>
      <div className="flex items-center gap-3">
        <select
          value={themeKey}
          onChange={(e) => setThemeKey(e.target.value)}
          className="p-1 rounded-md"
        >
          {Object.keys(themes).map((k) => (
            <option key={k} value={k}>{themes[k].name}</option>
          ))}
        </select>
        <button onClick={() => setSoundOn((s) => !s)} className="px-3 py-1 rounded-md bg-white/60">
          {soundOn ? "🔊" : "🔈"}
        </button>
      </div>
    </header>
  );
}

function Sidebar({ rooms, currentRoom, setCurrentRoom, addRoom, chars, currentCharId, setCurrentCharId, setShowCreateChar, setShowProfileEditor, exportRoom }) {
  const [newRoomName, setNewRoomName] = useState("");
  return (
    <aside className="w-64 border-r p-3 bg-white/40 flex flex-col gap-3">
      <div className="font-semibold">Rooms</div>
      <div className="flex-1 overflow-auto">
        {rooms.map((r) => (
          <div key={r.id} className={`p-2 rounded-md cursor-pointer ${r.id === currentRoom ? "bg-amber-100" : "hover:bg-white/70"}`} onClick={() => setCurrentRoom(r.id)}>
            <div className="font-medium">{r.name}</div>
            <div className="text-xs text-gray-600">{r.id}</div>
            <div className="mt-1 flex gap-2">
              <button className="text-xs underline" onClick={(e) => { e.stopPropagation(); exportRoom(r.id); }}>Export</button>
            </div>
          </div>
        ))}
      </div>
      <div className="flex gap-2">
        <input placeholder="New room" value={newRoomName} onChange={(e) => setNewRoomName(e.target.value)} className="flex-1 p-1 rounded-md" />
        <button onClick={() => { if (newRoomName.trim()) { addRoom(newRoomName.trim()); setNewRoomName(""); } }} className="px-3 bg-green-300 rounded-md">Add</button>
      </div>

      <div className="pt-2 border-t">
        <div className="font-semibold">Characters</div>
        <div className="flex flex-col gap-2 mt-2">
          {chars.map((c) => (
            <div key={c.id} className={`p-2 rounded-md flex items-center gap-2 ${c.id === currentCharId ? "bg-rose-50" : ""}`}>
              <div style={{ width: 36, height: 36, borderRadius: 8, background: c.color }} className="flex items-center justify-center text-white font-bold">{c.name.slice(0,2)}</div>
              <div className="flex-1">
                <div className="font-medium">{c.name}</div>
                <div className="text-xs text-gray-600">{c.species} • {c.pronouns}</div>
              </div>
              <div className="flex gap-1">
                <button onClick={() => setCurrentCharId(c.id)} className="px-2 py-1 bg-sky-200 rounded-md">Use</button>
                <button onClick={() => { navigator.clipboard?.writeText(c.id); alert('Copied ID'); }} className="px-2 py-1 bg-gray-200 rounded-md">Copy ID</button>
              </div>
            </div>
          ))}
          <button onClick={() => setShowCreateChar(true)} className="mt-2 bg-pink-200 p-2 rounded-md">Create New</button>
        </div>
      </div>
    </aside>
  );
}

function RoomHeader({ room }) {
  if (!room) return null;
  return (
    <div className="mb-3 flex items-center justify-between">
      <div className="flex items-center gap-3">
        <div className="text-xl font-bold">{room.name}</div>
        <div className="text-xs text-gray-600">{room.bg} • ambience: {room.ambience}</div>
      </div>
      <div className="text-sm text-gray-700">🌆 New Angelus — Rusty’s vibes</div>
    </div>
  );
}

function MessageList({ messages, chars, currentCharId, onEdit, onDelete }) {
  const [editingId, setEditingId] = useState(null);
  const [editingText, setEditingText] = useState("");

  function startEdit(m) {
    setEditingId(m.id);
    setEditingText(m.text);
  }

  return (
    <div className="flex flex-col gap-3">
      {messages.map((m) => {
        const char = chars.find((c) => c.id === m.charId) || { name: m.name, color: m.color };
        const mine = currentCharId && currentCharId === m.charId;
        return (
          <div key={m.id} className={`p-2 rounded-md ${mine ? "self-end bg-white/90" : "bg-white/80"} shadow-sm`}>
            <div className="flex items-center gap-3">
              <div style={{ width: 42, height: 42, borderRadius: 8, background: char.color }} className="flex items-center justify-center text-white font-bold">{char.name.slice(0,2)}</div>
              <div className="flex-1">
                <div className="flex items-center justify-between gap-3">
                  <div>
                    <div className="font-medium">{char.name} <span className="text-xs text-gray-500">{new Date(m.time).toLocaleTimeString()}</span></div>
                    <div className="text-sm mt-1 break-words">{renderMessageText(m.text)}</div>
                    {m.image && <img src={m.image} alt="attach" className="mt-2 max-w-xs rounded-md border" />}
                    {m.edited && <div className="text-xs text-gray-500">(edited)</div>}
                  </div>

                  <div className="flex flex-col items-end gap-2">
                    {mine && (
                      <>
                        <button className="text-xs underline" onClick={() => startEdit(m)}>Edit</button>
                        <button className="text-xs underline text-red-500" onClick={() => onDelete(m.id)}>Delete</button>
                      </>
                    )}
                  </div>
                </div>
                {editingId === m.id && (
                  <div className="mt-2 flex gap-2">
                    <input value={editingText} onChange={(e) => setEditingText(e.target.value)} className="flex-1 p-1 rounded-md" />
                    <button onClick={() => { onEdit(m.id, editingText); setEditingId(null); }} className="px-3 bg-green-300 rounded-md">Save</button>
                    <button onClick={() => setEditingId(null)} className="px-3 bg-gray-200 rounded-md">Cancel</button>
                  </div>
                )}
              </div>
            </div>
          </div>
        );
      })}
      {messages.length === 0 && <div className="text-center text-gray-500 py-10">No messages yet — be the first to drop a meow!</div>}
    </div>
  );
}

function renderMessageText(text) {
  // render simple markdown-ish and emotes
  if (!text) return null;
  // convert *action* to italic
  let t = text.replace(/\*(.*?)\*/g, (_, g) => `<i>${g}</i>`);
  // convert :emote: style (we also have plain emoji)
  t = t.replace(/:(\w+):/g, (_, g) => {
    const map = { catdance: '💃😺', pusheen: '🐱', paw: '🐾' };
    return map[g] || `:${g}:`;
  });
  return <div dangerouslySetInnerHTML={{ __html: t }} />;
}

function CreateCharModal({ onClose, onCreate }) {
  const [name, setName] = useState("");
  const [pronouns, setPronouns] = useState("they/them");
  const [species, setSpecies] = useState("human");
  const [color, setColor] = useState("#7f9cf5");
  const [bio, setBio] = useState("");
  const [avatar, setAvatar] = useState(null);

  function submit() {
    onCreate({ name, pronouns, species, color, bio, avatar });
  }

  return (
    <div className="fixed inset-0 bg-black/40 flex items-center justify-center">
      <div className="bg-white p-4 rounded-lg w-96">
        <h3 className="text-lg font-bold">Create Character</h3>
        <div className="mt-2 flex flex-col gap-2">
          <input placeholder="Name" value={name} onChange={(e) => setName(e.target.value)} className="p-2 rounded-md" />
          <input placeholder="Pronouns" value={pronouns} onChange={(e) => setPronouns(e.target.value)} className="p-2 rounded-md" />
          <input placeholder="Species" value={species} onChange={(e) => setSpecies(e.target.value)} className="p-2 rounded-md" />
          <input type="color" value={color} onChange={(e) => setColor(e.target.value)} className="p-1 rounded-md" />
          <textarea placeholder="Bio" value={bio} onChange={(e) => setBio(e.target.value)} className="p-2 rounded-md" />
          <input type="file" accept="image/*" onChange={(e) => {
            const reader = new FileReader();
            reader.onload = (ev) => setAvatar(ev.target.result);
            reader.readAsDataURL(e.target.files[0]);
          }} />
        </div>
        <div className="mt-3 flex justify-end gap-2">
          <button onClick={onClose} className="px-3 py-1 rounded-md bg-gray-200">Cancel</button>
          <button onClick={submit} className="px-3 py-1 rounded-md bg-pink-300">Create</button>
        </div>
      </div>
    </div>
  );
}

function ProfileEditor({ char, onClose, onSave }) {
  const [data, setData] = useState(char || {});
  useEffect(() => setData(char || {}), [char]);
  if (!char) return null;
  return (
    <div className="fixed inset-0 bg-black/40 flex items-center justify-center">
      <div className="bg-white p-4 rounded-lg w-96">
        <h3 className="text-lg font-bold">Edit Profile: {char.name}</h3>
        <div className="mt-2 flex flex-col gap-2">
          <input value={data.name || ""} onChange={(e) => setData({ ...data, name: e.target.value })} className="p-2 rounded-md" />
          <input value={data.pronouns || ""} onChange={(e) => setData({ ...data, pronouns: e.target.value })} className="p-2 rounded-md" />
          <input value={data.species || ""} onChange={(e) => setData({ ...data, species: e.target.value })} className="p-2 rounded-md" />
          <input type="color" value={data.color || "#7f9cf5"} onChange={(e) => setData({ ...data, color: e.target.value })} className="p-1 rounded-md" />
          <textarea value={data.bio || ""} onChange={(e) => setData({ ...data, bio: e.target.value })} className="p-2 rounded-md" />
        </div>
        <div className="mt-3 flex justify-end gap-2">
          <button onClick={onClose} className="px-3 py-1 rounded-md bg-gray-200">Cancel</button>
          <button onClick={() => onSave(data)} className="px-3 py-1 rounded-md bg-sky-300">Save</button>
        </div>
      </div>
    </div>
  );
}

function FloatingPaws() {
  return (
    <div aria-hidden className="pointer-events-none fixed right-4 bottom-4 flex flex-col gap-2">
      <div className="p-2 bg-white/90 rounded-full shadow animate-bounce">🐾</div>
      <div className="p-2 bg-white/90 rounded-full shadow">✨</div>
    </div>
  );
}

const EMOTES = [
  "😺",
  "😸",
  "😹",
  "🐾",
  "🐱",
  ":pusheen:",
  ":catdance:",
  "💕",
  "✨",
];

// ----------------- small utilities -----------------
function escapeHtmlSimple(s) {
  return s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
